#include <sys/sysinfo.h>
#include <cassert>
#include <iostream>
#include <string>
#include <stdexcept>
#include <chrono>
#include <algorithm>
#include <limits>

#include "audio_encoder.hh"
#include "conversion.hh"
#include "timestamp.hh"

using namespace std;
using namespace chrono;

AudioEncoder::AudioEncoder(const uint16_t sample_rate = 8000,
                           const uint16_t num_channel = 1,
                           const uint16_t bitrate = 24000,
                           const string & output_path)
  : sample_rate_(sample_rate), num_channel_(num_channel),
    bitrate_(bitrate), output_fd_() {

    // open the output file
    if (not output_path.empty()) {
    output_fd_ = FileDescriptor(check_syscall(
        open(output_path.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644)));
    }

    // initialize Opus encoder
    opus::Encoder encoder(sample_rate, num_channels, OPUS_APPLICATION_AUDIO, expected_loss_percent);
    if (!encoder.valid()) {
        throw runtime_error("Failed to create Opus encoder\n") << endl;
    }

    // set bitrate
    if (!encoder.SetBitrate(target_bitrate)) {
        throw runtime_error("Failed to set bitrate\n") << endl;
    }

    cerr << "Initialized Opus audio encoder" << endl;
}


void AudioEncoder::encode_audio(const RawAudio & raw_audio)
{
    const auto audio_generation_ts = timestamp_us();

    // calculate buffer size for the worst case scenario
    opus_int32 max_data_bytes = opus_packet_get_samples_per_frame(
        raw_audio.get_opus_audio(), sample_rate_)
        * num_channel_ * sizeof(opus_int16);
    unsigned char *cbits = (unsigned char *)malloc(max_data_bytes);

    // encode raw_audio into opus frame
    int num_bytes = opus_encode(encoder_, raw_audio.get_opus_audio(), 
        raw_audio.get_frame_size(), cbits, max_data_bytes);

    if (num_bytes < 0) {
    throw runtime_error("Opus encoding failed");
    }

    // write encoded audio to file
    if (output_fd_) {
    const auto audio_encoded_ts = timestamp_us();
    const double encode_time_ms = (audio_encoded_ts - audio_generation_ts) / 1000.0;

    output_fd_->write(reinterpret_cast<const char *>(cbits), num_bytes);

    output_fd_->write(to_string(frame_id_) + "," +
                        to_string(bitrate_) + "," +
                        to_string(num_bytes) + "," + 
                        to_string(encode_time_ms) + "\n"); // ms
    }

    free(cbits);

    // move onto the next frame
    frame_id_++;
}
